1. #### Про copy и deepcopy

Поверхностное копирование (Shallow Copy)

Поверхностное копирование создаёт новый объект, но внутренние объекты остаются ссылками на оригиналы. Это значит, что если скопировать список, содержащий вложенные списки или объекты, то при изменении вложенных элементов в одной копии — изменения будут видны и в другой.

Способы создания поверхностной копии: срезы, list() и подобные ему, copy()

Глубокое копирование (Deep Copy)

Глубокое копирование создаёт полностью независимый объект, включая вложенные структуры данных. Изменения в одной копии никак не затрагивают другую.

Как создать глубокую копию: copy.deepcopy()

Для неизменяемых объектов любое копирование создает новую ссылку на тот же самый объект.


2. #### Про массивы

Массив — это непрерывный блок памяти, в котором хранятся элементы одного типа. Все элементы располагаются последовательно друг за другом, без промежутков.
Индексация в массиве — это способ быстро обратиться к конкретному элементу массива с использованием его позиции. Эта позиция называется индексом.

Массив в памяти располагается непрерывным блоком. Это значит, что зная:
адрес первого элемента, размер типа данных и индекс, который тебе нужен, мы можем вычислить адрес любого элемента за O(1) (константное время).

3. #### Генератор 

Генератор — это функция или выражение, которое позволяет лениво итерировать последовательность значений по одному за раз, вместо того чтобы загружать все значения сразу в память. Вместо return используется yield, программа выполняется от yield до yield, каждый раз передавая управление.

Методы:
next(gen) - Возвращает следующее значение, если оно есть. Иначе -StopIteration.
send(value) - Возобновляет выполнение генератора, можно передать значение внутрь.
throw(exc) - Бросает исключение в генератор в точку, где он приостановлен.
close() - Останавливает генератор и освобождает ресурсы.

4. #### Контекстный менеджер

Контекстный менеджер в Python — это объект, который управляет ресурсами, обеспечивая их корректное выделение и освобождение. Он используется в конструкции with, которая гарантирует выполнение определённых действий при входе в блок кода и при выходе из него, даже в случае возникновения исключений.

Контекстный менеджер реализует два специальных метода:

- __enter__(self): выполняется при входе в блок with. Он может возвращать ресурс, который будет присвоен переменной после as.
    
- __exit__(self, exc_type, exc_value, traceback): выполняется при выходе из блока with, даже если внутри блока произошло исключение. Этот метод отвечает за освобождение ресурсов и обработку исключений.

5. #### Принципы ООП

Инкапсуляция — это сокрытие внутренней реализации объекта и предоставление доступа к данным только через специально определённые методы (геттеры и сеттеры). Тут же _protected и __private атрибуты и методы.

Наследование — это механизм, позволяющий создавать новые классы на основе уже существующих, перенимая их свойства и методы.

Полиморфизм — это способность объектов с одинаковым интерфейсом (методом) вести себя по-разному в зависимости от типа объекта.

Абстракция — это принцип, позволяющий выделить основные характеристики объекта, скрыв его сложную внутреннюю реализацию.

6. #### SOLID

S - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.

O - Open closed Principle - принцип открытости-закрытости.Классы должны быть открыты для расширения, но закрыты для изменения.

L - Liskov substitution Principle - принцип подстановки Барбары Лисков.Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.

I - Interface Segregation Principle - принцип разделения интерфейсов.Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

D - Dependency Inversion Principle - принцип инверсии зависимостей.Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.